/*
 *  This file is part of Block IDLE.
 *
 *  Block IDLE is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Block IDLE is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *   along with Block IDLE.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.icst.blockidle.bean;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

import com.icst.blockidle.bean.utils.BeanArrayCloneUtils;
import com.icst.blockidle.bean.utils.BeansUIDConstants;

/**
 * Represents a data type in the system with information about its name and inheritance hierarchy.
 *
 * <p>The {@code DatatypeBean} class encapsulates metadata for a class or type used in the code
 * generation or processing pipeline. It includes both the simple class name and the fully qualified
 * class name, and maintains a list of its super types (i.e., its inheritance hierarchy).
 *
 * <p>This class is designed to support type checking, hierarchical relationship inspection,
 * cloning, and formatted string representation of the type's lineage.
 *
 * <p>Key Features:
 *
 * <ul>
 *   <li>Stores both the simple class name and the fully qualified class name.
 *   <li>Supports a recursive structure to represent super types.
 *   <li>Provides a method to determine whether a type is a supertype or equal to another type.
 *   <li>Implements deep cloning via the {@link CloneableBean} interface.
 *   <li>Overrides {@code toString()} to return a formatted inheritance tree.
 * </ul>
 *
 * <p>Example usage:
 *
 * <pre>{@code
 * DatatypeBean objectType = new DatatypeBean("java.lang.Object", "Object");
 * DatatypeBean stringType = new DatatypeBean("java.lang.String", "String");
 * stringType.addSuperType(objectType);
 *
 * System.out.println(stringType);
 * }</pre>
 *
 * <b>Note: </b>DatatypeBean are generally generated by a automated process when generating blocks
 * through exptension module.
 *
 * <p>Output:
 *
 * <pre>
 * ```
 * return type
 * java.lang.String
 *     java.lang.Object
 * ```
 * </pre>
 *
 * @see CloneableBean
 * @see BeanArrayCloneUtils
 */
public class DatatypeBean implements CloneableBean<DatatypeBean>, Serializable {

	/** The serial version UID used for serialization compatibility. */
	public static final long serialVersionUID = BeansUIDConstants.DATATYPE_BEAN_BEAN;

	private String fullClassName;
	private String className;
	private ArrayList<DatatypeBean> superTypes;

	/**
	 * Constructs a {@code DatatypeBean} with the given full class name and class name.
	 *
	 * @param fullClassName the fully qualified name of the class
	 * @param className the simple name of the class
	 */
	public DatatypeBean(String fullClassName, String className) {
		this.fullClassName = fullClassName;
		this.className = className;
		superTypes = new ArrayList<>();
	}

	/**
	 * Constructs a {@code DatatypeBean} with the given class names and list of super types.
	 *
	 * @param fullClassName the fully qualified name of the class
	 * @param className the simple name of the class
	 * @param superTypes the list of super types (inheritance)
	 */
	public DatatypeBean(String fullClassName, String className, ArrayList<DatatypeBean> superTypes) {
		this.fullClassName = fullClassName;
		this.className = className;
		this.superTypes = superTypes;
	}

	/**
	 * Returns the fully qualified class name.
	 *
	 * @return the full class name as a string
	 */
	public String getFullClassName() {
		return fullClassName;
	}

	/**
	 * Returns the list of super types for this data type.
	 *
	 * @return a list of {@link DatatypeBean} representing the super types
	 */
	public ArrayList<DatatypeBean> getSuperTypes() {
		return superTypes;
	}

	/**
	 * Adds a new super type to the list of this data typeâ€™s super types.
	 *
	 * @param superType the {@link DatatypeBean} representing the super type to add
	 */
	public void addSuperType(DatatypeBean superType) {
		superTypes.add(superType);
	}

	/**
	 * Returns the simple class name.
	 *
	 * @return the class name as a string
	 */
	public String getClassName() {
		return this.className;
	}

	/**
	 * Sets the simple class name.
	 *
	 * @param className the name of the class to set
	 */
	public void setClassName(String className) {
		this.className = className;
	}

	public boolean isSuperTypeOrDatatype(DatatypeBean datatype) {
		return isSuperTypeHelperOrDatatype(datatype, new HashSet<>());
	}

	/**
	 * Checks whether the provided {@code datatype} is either equal to this type or one of its super
	 * types (recursively).
	 *
	 * @param datatype the data type to compare
	 * @return {@code true} if the given type is a super type or the same as this one
	 */
	private boolean isSuperTypeHelperOrDatatype(DatatypeBean datatype, Set<DatatypeBean> visited) {
		if (datatype == null || visited.contains(datatype)) {
			return false;
		}

		if (equals(datatype)) {
			return true;
		}
		visited.add(datatype);

		for (DatatypeBean mDatatype : superTypes) {
			if (mDatatype.isSuperTypeOrDatatype(datatype)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Checks if this data type is equal to another object based on the full class name.
	 *
	 * @param o the object to compare with
	 * @return {@code true} if both are {@code DatatypeBean} instances with the same full class name
	 */
	@Override
	public boolean equals(Object o) {
		if (this == o)
			return true;
		if (o == null || getClass() != o.getClass())
			return false;
		DatatypeBean datatype = (DatatypeBean) o;
		return fullClassName.equals(datatype.fullClassName);
	}

	/**
	 * Returns the hash code based on the full class name.
	 *
	 * @return hash code of this data type
	 */
	@Override
	public int hashCode() {
		return Objects.hash(fullClassName);
	}

	/**
	 * Creates a deep clone of this DatatypeBean, including all of its super DatatypeBean.
	 *
	 * <p>Uses {@link BeanArrayCloneUtils#clone(java.util.ArrayList)} to clone the super types list.
	 *
	 * @return a new instance that is a deep copy of this object
	 */
	@Override
	public DatatypeBean cloneBean() {
		String mClassName = className == null ? null : new String(className);
		String mFullClassName = fullClassName == null ? null : new String(fullClassName);
		ArrayList<DatatypeBean> clonedSuperTypes = BeanArrayCloneUtils.clone(superTypes);
		return new DatatypeBean(mFullClassName, mClassName, clonedSuperTypes);
	}

	private String getInheritanceAsString(DatatypeBean datatype, int level, Set<DatatypeBean> visited,
			StringBuilder strBuilder) {
		if (datatype == null) {
			return "";
		}
		visited.add(datatype);
		for (int i = 0; i < level; i++) {
			strBuilder.append("\t");
		}
		strBuilder.append(datatype.getFullClassName());
		strBuilder.append("\n");
		for (DatatypeBean superType : datatype.getSuperTypes()) {
			getInheritanceAsString(superType, level + 1, visited, strBuilder);
		}
		return "```return type\n" + strBuilder.toString() + "```";
	}

	/**
	 * Returns a formatted string representation of this {@link DatatypeBean}'s inheritance
	 * hierarchy.
	 *
	 * <p>This method provides a hierarchical view of the current data type and its super types,
	 * formatted with indentation to reflect the depth of inheritance. It uses tabs to indent each
	 * level and appends each class's fully qualified name on a new line.
	 *
	 * <p>The output is wrapped in Markdown-style code block formatting to improve rendering in
	 * tools that support such styling.
	 *
	 * <p>Example output:
	 *
	 * <pre>{@code
	 * ```
	 * return type
	 * com.example.MyClass
	 *     com.example.BaseClass
	 *         java.lang.Object
	 * ```
	 * }</pre>
	 *
	 * @return a formatted string representing the inheritance tree of this type
	 * @see #getInheritanceAsString(DatatypeBean, int, Set, StringBuilder)
	 */
	@Override
	public String toString() {
		return getInheritanceAsString(this, 0, new HashSet<>(), new StringBuilder());
	}
}
